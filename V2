# app.py
# Manual ballooning tool (NO OCR / NO Auto Detect / NO Tesseract)
# Features:
# - Open multi-page PDF (navigate pages) or single image
# - Continuous balloon numbering across ALL pages (page 1 continues into page 2, etc.)
# - Left-click: add balloon (unless clicking an existing balloon)
# - Select + drag balloons
# - Delete selected (Del/Backspace), Undo last
# - Zoom with mouse wheel
# - Pan by holding RIGHT mouse button and dragging
# - Rotate 90° CW/CCW, Reset rotation (affects current page view; clears balloons on that page)
# - Export ALL PAGES:
#     * If PDF selected: exports a multi-page PDF (ALL pages)
#     * If PNG/JPEG selected and source is a multi-page PDF: exports a numbered image per page
#       (e.g., output_p001.png, output_p002.png, ...)

import sys
import os
from dataclasses import dataclass
from typing import Dict, List, Optional

from PySide6.QtCore import Qt, QPointF, QRectF, QSizeF, QBuffer, QByteArray, QIODevice
from PySide6.QtGui import (
    QAction,
    QBrush,
    QFont,
    QImage,
    QPainter,
    QPen,
    QPixmap,
    QTransform,
)
from PySide6.QtWidgets import (
    QApplication,
    QFileDialog,
    QGraphicsItem,
    QGraphicsPixmapItem,
    QGraphicsScene,
    QGraphicsView,
    QLabel,
    QMainWindow,
    QMessageBox,
    QSpinBox,
    QToolBar,
    QVBoxLayout,
    QWidget,
)

import fitz  # PyMuPDF


# -----------------------------
# Data models
# -----------------------------
@dataclass
class Balloon:
    balloon_id: int
    x: float
    y: float
    radius: float


# -----------------------------
# Graphics items
# -----------------------------
class BalloonItem(QGraphicsItem):
    """Numbered balloon."""

    def __init__(self, balloon: Balloon):
        super().__init__()
        self.balloon = balloon
        self.setFlags(
            QGraphicsItem.ItemIsSelectable
            | QGraphicsItem.ItemIsMovable
            | QGraphicsItem.ItemIsFocusable
        )

    def boundingRect(self) -> QRectF:
        r = self.balloon.radius
        return QRectF(-r, -r, 2 * r, 2 * r)

    def paint(self, painter: QPainter, option, widget=None):
        r = self.balloon.radius

        painter.setPen(QPen(Qt.black, 2))
        painter.setBrush(QBrush(Qt.white))
        painter.drawEllipse(QPointF(0, 0), r, r)

        text = str(self.balloon.balloon_id)
        digits = len(text)
        scale = 1.25 if digits == 1 else (1.05 if digits == 2 else 0.9)

        font = QFont()
        font.setBold(True)
        font.setPixelSize(max(10, int(r * scale)))
        painter.setFont(font)
        painter.setPen(Qt.black)

        rect = QRectF(-r, -r, 2 * r, 2 * r)
        painter.drawText(rect, Qt.AlignCenter, text)


# -----------------------------
# View (Zoom + Right-drag pan)
# -----------------------------
class DrawingView(QGraphicsView):
    def __init__(self, scene, parent=None):
        super().__init__(scene, parent)
        self.main_window: Optional["MainWindow"] = None

        self.setRenderHints(QPainter.Antialiasing | QPainter.SmoothPixmapTransform)
        self.setDragMode(QGraphicsView.NoDrag)
        self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)

        self._panning = False
        self._pan_start = None
        self.setContextMenuPolicy(Qt.NoContextMenu)

    def wheelEvent(self, event):
        factor = 1.15 if event.angleDelta().y() > 0 else 1 / 1.15
        self.scale(factor, factor)

    def mousePressEvent(self, event):
        if event.button() == Qt.RightButton:
            self._panning = True
            self._pan_start = event.position().toPoint()
            self.setCursor(Qt.ClosedHandCursor)
            event.accept()
            return

        if event.button() == Qt.LeftButton and self.main_window:
            item = self.itemAt(event.position().toPoint())

            if isinstance(item, BalloonItem):
                super().mousePressEvent(event)
                return

            pos = self.mapToScene(event.position().toPoint())
            self.main_window.add_balloon(pos.x(), pos.y())
            return

        super().mousePressEvent(event)

    def mouseMoveEvent(self, event):
        if self._panning and self._pan_start is not None:
            delta = event.position().toPoint() - self._pan_start
            self._pan_start = event.position().toPoint()

            self.horizontalScrollBar().setValue(self.horizontalScrollBar().value() - delta.x())
            self.verticalScrollBar().setValue(self.verticalScrollBar().value() - delta.y())

            event.accept()
            return

        super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        if event.button() == Qt.RightButton and self._panning:
            self._panning = False
            self._pan_start = None
            self.unsetCursor()
            event.accept()
            return

        super().mouseReleaseEvent(event)


# -----------------------------
# Main window
# -----------------------------
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Ballooning Tool (Manual, Multi-page PDF)")
        self.resize(1200, 800)

        self.scene = QGraphicsScene(self)
        self.view = DrawingView(self.scene, self)
        self.view.main_window = self

        # Current displayed image/page
        self.base_image: Optional[QImage] = None
        self.original_image: Optional[QImage] = None

        # PDF state
        self.pdf_doc: Optional[fitz.Document] = None
        self.pdf_path: Optional[str] = None
        self.page_count: int = 1
        self.current_page_index: int = 0  # 0-based
        self.pdf_zoom: float = 3.0
        self._render_cache: Dict[int, QImage] = {}

        # Balloons stored per page (continuous IDs across all pages)
        self.balloons_by_page: Dict[int, List[Balloon]] = {}
        self.balloon_items: List[BalloonItem] = []  # items in scene for current page

        self.radius_spin = QSpinBox()
        self.radius_spin.setRange(10, 80)
        self.radius_spin.setValue(18)
        self.radius_spin.setToolTip("Bubble radius (px) for new balloons")

        # Page controls
        self.page_spin = QSpinBox()
        self.page_spin.setRange(1, 1)
        self.page_spin.setValue(1)
        self.page_spin.setToolTip("PDF Page")
        self.page_spin.valueChanged.connect(self._on_page_spin_changed)

        self.page_label = QLabel(" / 1")
        self.page_label.setToolTip("Current page / total pages")

        self.status = QLabel("Open a drawing. Left-click to balloon. Right-drag to pan. Wheel to zoom.")
        self.statusBar().addWidget(self.status)

        self._build_ui()

    def _build_ui(self):
        tb = QToolBar("Tools")
        self.addToolBar(tb)

        tb.addAction(self._action("Open", self.open_file))
        tb.addAction(self._action("Export (ALL pages)", self.export_output))

        tb.addSeparator()
        self.prev_act = self._action("◀ Prev", self.prev_page)
        self.next_act = self._action("Next ▶", self.next_page)
        tb.addAction(self.prev_act)
        tb.addAction(self.next_act)
        tb.addWidget(QLabel(" Page: "))
        tb.addWidget(self.page_spin)
        tb.addWidget(self.page_label)

        tb.addSeparator()
        tb.addAction(self._action("Undo", self.undo_last))
        tb.addAction(self._action("Delete Selected", self.delete_selected))

        tb.addSeparator()
        tb.addAction(self._action("Rotate ⟳ 90°", lambda: self.rotate(90)))
        tb.addAction(self._action("Rotate ⟲ 90°", lambda: self.rotate(-90)))
        tb.addAction(self._action("Reset Rotation", self.reset_rotation))

        tb.addSeparator()
        tb.addWidget(QLabel(" Bubble size: "))
        tb.addWidget(self.radius_spin)

        container = QWidget()
        layout = QVBoxLayout(container)
        layout.addWidget(self.view)
        self.setCentralWidget(container)

        self._update_page_controls()

    def _action(self, text, slot):
        act = QAction(text, self)
        act.triggered.connect(slot)
        return act

    # -----------------------------
    # Helpers
    # -----------------------------
    def _current_page_key(self) -> int:
        return self.current_page_index if self.pdf_doc is not None else 0

    def _total_balloons(self) -> int:
        return sum(len(v) for v in self.balloons_by_page.values())

    def _renumber_all_pages(self):
        """Renumber balloons continuously across all pages (page order)."""
        next_id = 1
        page_iter = range(self.page_count if self.pdf_doc is not None else 1)
        for p in page_iter:
            page_list = self.balloons_by_page.get(p, [])
            for b in page_list:
                b.balloon_id = next_id
                next_id += 1

        # Update current page items to match their balloons
        page_key = self._current_page_key()
        current_list = self.balloons_by_page.get(page_key, [])
        for item, b in zip(self.balloon_items, current_list):
            item.balloon.balloon_id = b.balloon_id

        self.scene.update()
        self._update_status()

    def _update_page_controls(self):
        is_pdf = self.pdf_doc is not None and self.page_count > 1
        self.prev_act.setEnabled(is_pdf and self.current_page_index > 0)
        self.next_act.setEnabled(is_pdf and self.current_page_index < self.page_count - 1)
        self.page_spin.setEnabled(is_pdf)

    # -----------------------------
    # File loading
    # -----------------------------
    def open_file(self):
        path, _ = QFileDialog.getOpenFileName(
            self, "Open Drawing", "", "PDF (*.pdf);;Images (*.png *.jpg *.jpeg *.bmp *.tif *.tiff)"
        )
        if not path:
            return

        try:
            if path.lower().endswith(".pdf"):
                self._open_pdf(path)
            else:
                self._open_image(path)
        except Exception as e:
            QMessageBox.critical(self, "Open Failed", f"Failed to open file:\n{e}")

    def _open_pdf(self, pdf_path: str):
        self.pdf_doc = fitz.open(pdf_path)
        self.pdf_path = pdf_path
        self.page_count = int(self.pdf_doc.page_count)
        if self.page_count < 1:
            raise ValueError("PDF has no pages.")

        self.current_page_index = 0
        self._render_cache.clear()
        self.balloons_by_page.clear()

        self.page_spin.blockSignals(True)
        self.page_spin.setRange(1, self.page_count)
        self.page_spin.setValue(1)
        self.page_spin.blockSignals(False)
        self.page_label.setText(f" / {self.page_count}")

        self._load_pdf_page(0)
        self._update_page_controls()

    def _open_image(self, img_path: str):
        img = QImage(img_path)
        if img.isNull():
            raise ValueError("Could not open image.")

        self.pdf_doc = None
        self.pdf_path = None
        self.page_count = 1
        self.current_page_index = 0
        self._render_cache.clear()
        self.balloons_by_page.clear()

        self.page_spin.blockSignals(True)
        self.page_spin.setRange(1, 1)
        self.page_spin.setValue(1)
        self.page_spin.blockSignals(False)
        self.page_label.setText(" / 1")

        self.load_image(img, page_index=0)
        self._update_page_controls()

    def _render_pdf_page(self, page_index: int, zoom: float) -> QImage:
        assert self.pdf_doc is not None
        page = self.pdf_doc.load_page(page_index)
        mat = fitz.Matrix(zoom, zoom)
        pix = page.get_pixmap(matrix=mat, alpha=False)
        qimg = QImage(pix.samples, pix.width, pix.height, pix.stride, QImage.Format_RGB888)
        return qimg.copy()

    def _get_page_image(self, page_index: int) -> QImage:
        """Returns rendered image for a PDF page (cached). For image inputs, only page 0 exists."""
        if self.pdf_doc is None:
            assert self.base_image is not None
            return self.base_image

        if page_index in self._render_cache:
            return self._render_cache[page_index]
        img = self._render_pdf_page(page_index, self.pdf_zoom)
        self._render_cache[page_index] = img
        return img

    def _load_pdf_page(self, page_index: int):
        if self.pdf_doc is None:
            return
        page_index = max(0, min(page_index, self.page_count - 1))
        self.current_page_index = page_index

        img = self._get_page_image(page_index)
        self.load_image(img, page_index=page_index)

        self.page_spin.blockSignals(True)
        self.page_spin.setValue(page_index + 1)
        self.page_spin.blockSignals(False)

        self._update_page_controls()
        self._update_status()

    def _on_page_spin_changed(self, val: int):
        if self.pdf_doc is None:
            return
        self._load_pdf_page(val - 1)

    def prev_page(self):
        if self.pdf_doc is None:
            return
        self._load_pdf_page(self.current_page_index - 1)

    def next_page(self):
        if self.pdf_doc is None:
            return
        self._load_pdf_page(self.current_page_index + 1)

    # -----------------------------
    # Scene / page load
    # -----------------------------
    def load_image(self, image: QImage, page_index: int = 0):
        self.scene.clear()
        self.base_image = image
        self.original_image = image.copy()

        self.balloon_items.clear()

        pix = QPixmap.fromImage(image)
        self.scene.addItem(QGraphicsPixmapItem(pix))
        self.scene.setSceneRect(pix.rect())
        self.view.fitInView(self.scene.sceneRect(), Qt.KeepAspectRatio)

        page_balloons = self.balloons_by_page.get(page_index, [])
        for b in page_balloons:
            it = BalloonItem(b)
            it.setPos(b.x, b.y)
            self.scene.addItem(it)
            self.balloon_items.append(it)

        self._renumber_all_pages()

    # -----------------------------
    # Manual balloons (continuous numbering)
    # -----------------------------
    def add_balloon(self, x: float, y: float):
        if self.base_image is None:
            QMessageBox.information(self, "No drawing loaded", "Open a drawing first.")
            return

        page_key = self._current_page_key()
        page_list = self.balloons_by_page.setdefault(page_key, [])

        balloon_id = self._total_balloons() + 1
        radius = float(self.radius_spin.value())

        b = Balloon(balloon_id, x, y, radius)
        it = BalloonItem(b)
        it.setPos(x, y)

        self.scene.addItem(it)
        page_list.append(b)
        self.balloon_items.append(it)

        self._update_status()

    def undo_last(self):
        page_key = self._current_page_key()
        page_list = self.balloons_by_page.get(page_key, [])
        if not self.balloon_items or not page_list:
            return

        it = self.balloon_items.pop()
        self.scene.removeItem(it)
        page_list.pop()

        self._renumber_all_pages()

    def delete_selected(self):
        page_key = self._current_page_key()
        page_list = self.balloons_by_page.get(page_key, [])
        if not page_list:
            return

        selected_items = [it for it in self.balloon_items if it.isSelected()]
        if not selected_items:
            self.status.setText("No balloon selected. Click a balloon then press Delete.")
            return

        idxs = sorted((self.balloon_items.index(it) for it in selected_items), reverse=True)
        for idx in idxs:
            it = self.balloon_items[idx]
            self.scene.removeItem(it)
            self.balloon_items.pop(idx)
            page_list.pop(idx)

        self._renumber_all_pages()

    def keyPressEvent(self, event):
        if event.key() in (Qt.Key_Delete, Qt.Key_Backspace):
            self.delete_selected()
            return
        super().keyPressEvent(event)

    # -----------------------------
    # Rotate / Reset
    # (simple behavior: clear balloons on current page)
    # -----------------------------
    def rotate(self, angle_degrees: int):
        if self.base_image is None:
            return
        rotated = self.base_image.transformed(QTransform().rotate(angle_degrees), Qt.SmoothTransformation)

        page_key = self._current_page_key()
        self.balloons_by_page[page_key] = []

        # If PDF, this rotation is a visual-only transform; drop cache so page re-renders on next visit if needed
        if self.pdf_doc is not None:
            self._render_cache.pop(self.current_page_index, None)

        self.load_image(rotated, page_index=page_key)
        self.status.setText("Rotated. (Balloons cleared for this page.)")

    def reset_rotation(self):
        page_key = self._current_page_key()
        self.balloons_by_page[page_key] = []

        if self.pdf_doc is not None:
            self._render_cache.pop(self.current_page_index, None)
            self._load_pdf_page(self.current_page_index)
            self.status.setText("Rotation reset. (Balloons cleared for this page.)")
            return

        if self.original_image is not None:
            self.load_image(self.original_image.copy(), page_index=page_key)
            self.status.setText("Rotation reset. (Balloons cleared for this page.)")

    # -----------------------------
    # Rendering helpers for Export ALL pages
    # -----------------------------
    def _render_page_with_balloons_to_image(self, page_index: int) -> QImage:
        """
        Render a specific page (background image + that page's balloons) to a QImage.
        This does NOT depend on what's currently on-screen.
        """
        bg = self._get_page_image(page_index)

        tmp_scene = QGraphicsScene()
        pix = QPixmap.fromImage(bg)
        tmp_scene.addItem(QGraphicsPixmapItem(pix))
        tmp_scene.setSceneRect(pix.rect())

        # Draw balloons from data for that page
        for b in self.balloons_by_page.get(page_index, []):
            it = BalloonItem(b)
            it.setPos(b.x, b.y)
            tmp_scene.addItem(it)

        rect = tmp_scene.sceneRect()
        out_img = QImage(int(rect.width()), int(rect.height()), QImage.Format_ARGB32)
        out_img.fill(Qt.white)

        p = QPainter(out_img)
        tmp_scene.render(p)
        p.end()
        return out_img

    @staticmethod
    def _qimage_to_png_bytes(img: QImage) -> bytes:
        ba = QByteArray()
        buf = QBuffer(ba)
        buf.open(QIODevice.WriteOnly)
        img.save(buf, "PNG")
        buf.close()
        return bytes(ba)

    def _export_all_pages_to_pdf(self, pdf_path: str, dpi: int = 300) -> bool:
        """
        Create a multi-page PDF containing ALL pages with balloons.
        Uses PyMuPDF to create pages sized to the rendered image.
        """
        try:
            out_doc = fitz.open()

            page_total = self.page_count if self.pdf_doc is not None else 1
            for i in range(page_total):
                img = self._render_page_with_balloons_to_image(i)

                # points = inches * 72; inches = px / dpi => points = px * 72 / dpi
                w_pts = img.width() * 72.0 / dpi
                h_pts = img.height() * 72.0 / dpi

                page = out_doc.new_page(width=w_pts, height=h_pts)

                png_bytes = self._qimage_to_png_bytes(img)
                rect = fitz.Rect(0, 0, w_pts, h_pts)
                page.insert_image(rect, stream=png_bytes)

            out_doc.save(pdf_path)
            out_doc.close()
            return True
        except Exception:
            return False

    def _export_all_pages_to_images(self, base_path: str, fmt: str) -> bool:
        """
        Export ALL pages to separate image files.
        base_path is whatever user picked, like C:\...\output.png
        We write output_p001.png ... output_pXYZ.png (or .jpg)
        """
        try:
            root, ext = os.path.splitext(base_path)
            ext = ext.lower()
            if fmt.lower() == "jpg" and ext not in (".jpg", ".jpeg"):
                ext = ".jpg"
            if fmt.lower() == "png" and ext != ".png":
                ext = ".png"

            page_total = self.page_count if self.pdf_doc is not None else 1
            pad = len(str(page_total))

            for i in range(page_total):
                img = self._render_page_with_balloons_to_image(i)
                out_path = f"{root}_p{str(i+1).zfill(pad)}{ext}"
                if not img.save(out_path):
                    return False
            return True
        except Exception:
            return False

    # -----------------------------
    # Export (ALL pages)
    # -----------------------------
    def export_output(self):
        if self.base_image is None:
            QMessageBox.information(self, "Nothing to export", "Open a drawing first.")
            return

        file_path, selected_filter = QFileDialog.getSaveFileName(
            self,
            "Export ballooned drawing (ALL pages)",
            "ballooned_output.pdf",
            "PDF (*.pdf);;PNG (*.png);;JPEG (*.jpg *.jpeg)",
        )
        if not file_path:
            return

        # Ensure numbering is consistent before export
        self._renumber_all_pages()

        # Decide format
        filt = selected_filter.upper()
        ext = os.path.splitext(file_path)[1].lower()

        if "PDF" in filt or ext == ".pdf":
            if ext != ".pdf":
                file_path += ".pdf"

            ok = self._export_all_pages_to_pdf(file_path, dpi=300)
            if not ok:
                QMessageBox.critical(self, "Save Failed", "Could not save the multi-page PDF.")
                return

            self.status.setText(f"Saved ALL pages to PDF: {os.path.basename(file_path)}")
            return

        # If user chose PNG/JPEG
        if "PNG" in filt or ext == ".png":
            ok = self._export_all_pages_to_images(file_path, fmt="png")
            if not ok:
                QMessageBox.critical(self, "Save Failed", "Could not export all pages as PNG images.")
                return
            self.status.setText("Saved ALL pages as PNG images (one file per page).")
            return

        # JPEG
        ok = self._export_all_pages_to_images(file_path, fmt="jpg")
        if not ok:
            QMessageBox.critical(self, "Save Failed", "Could not export all pages as JPEG images.")
            return
        self.status.setText("Saved ALL pages as JPEG images (one file per page).")

    # -----------------------------
    # Status helper
    # -----------------------------
    def _update_status(self, extra: str = ""):
        total = self._total_balloons()
        if self.pdf_doc is not None:
            base = f"Page {self.current_page_index + 1}/{self.page_count} | Total balloons: {total}"
        else:
            base = f"Total balloons: {total}"
        self.status.setText(base + (f" | {extra}" if extra else ""))


# -----------------------------
# Entry point
# -----------------------------
def main():
    app = QApplication(sys.argv)
    win = MainWindow()
    win.show()
    sys.exit(app.exec())


if __name__ == "__main__":
    main()
